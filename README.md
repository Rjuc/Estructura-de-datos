# Árbol Binario de Búsqueda - Estructura de Datos

## Descripción del Proyecto

El desarrollo del árbol binario de búsqueda para gestión alfabética de países surge como evolución natural del trabajo previo con listas doblemente enlazadas, aprovechando la experiencia adquirida en manipulación de referencias y gestión de memoria dinámica. La estructura implementada se especializa deliberadamente en el manejo de cadenas de texto, decisión que contrasta marcadamente con los ejemplos genéricos vistos en clase pero que responde a consideraciones prácticas sobre el tiempo de desarrollo y la claridad del código resultante. Durante las sesiones teóricas, el profesor presentó implementaciones que empleaban interfaces y tipos parametrizados, arquitectura que si bien demuestra principios sólidos de diseño orientado a objetos, añade capas de abstracción que pueden restar importancia a los algoritmos fundamentales para quienes recién se inician en estructuras arbóreas.

La construcción del proyecto requirió decisiones arquitectónicas concretas que divergen conscientemente de los materiales didácticos proporcionados durante el curso. Mientras los documentos de clase muestran árboles que operan con cualquier tipo comparable mediante genéricos de Java, la implementación actual trabaja exclusivamente con String, eliminando la complejidad sintáctica de declaraciones como T extends Comparable<T> que, aunque poderosas, introducen una curva de aprendizaje adicional sin beneficio tangible para el dominio específico de países. Esta simplificación permitió concentrar el esfuerzo de desarrollo en aspectos algorítmicos críticos como la eliminación de nodos con dos hijos, operación que consumió considerable tiempo de depuración incluso sin la complicación adicional de los tipos genéricos.

## Análisis de Decisiones Arquitectónicas

La incorporación de referencias al nodo padre en cada elemento del árbol representa quizás la decisión más significativa tomada durante el desarrollo, alejándose del diseño tradicional presentado en los materiales del curso. Los documentos proporcionados en clase implementan una estructura donde cada nodo mantiene únicamente referencias a sus hijos, filosofía que minimiza el consumo de memoria pero complica considerablemente las operaciones de eliminación. El código visto en clase requiere mantener un rastro del camino recorrido durante la búsqueda del nodo a eliminar, implementación que añade aproximadamente 35 líneas adicionales de código e introduce múltiples puntos potenciales de error. La decisión de incluir referencias parentales reduce esta complejidad a verificaciones directas, transformando operaciones que requerirían navegación desde la raíz en accesos inmediatos con costo temporal constante.

El tratamiento de la inmutabilidad del valor nodal marca otra divergencia fundamental respecto a los ejemplos académicos. Los materiales del profesor incluyen métodos setter para todos los atributos de los nodos, práctica que aunque ofrece flexibilidad aparente, introduce riesgos de corrupción estructural difíciles de detectar. Durante las pruebas iniciales del proyecto, se identificó un error sutil donde la modificación accidental del valor de un nodo rompía el ordenamiento del árbol, problema que consumió varias horas de depuración antes de optar por la inmutabilidad completa del campo valor. Esta restricción, ausente en los documentos de clase, fuerza cualquier "actualización" a realizarse mediante eliminación e inserción explícitas, garantizando la coherencia estructural pero sacrificando eficiencia en escenarios de modificación frecuente que, afortunadamente, no aplican al dominio de países donde los nombres permanecen relativamente estables.

La implementación de métodos auxiliares como esHoja() y tieneUnHijo() responde a lecciones aprendidas durante el desarrollo del primer laboratorio con listas enlazadas, donde la repetición de verificaciones de nulidad en múltiples lugares del código generó errores sutiles y dificultó el mantenimiento. Los ejemplos proporcionados por el profesor realizan estas verificaciones inline mediante expresiones booleanas complejas que, aunque correctas, resultan propensas a errores de transcripción y dificultan la comprensión inmediata del código. La encapsulación de estas verificaciones en métodos con nombres descriptivos no solo mejora la legibilidad sino que reduce la probabilidad de errores lógicos.

## Implementación de Operaciones Críticas

El algoritmo de eliminación para nodos con dos hijos presentó desafíos técnicos particulares que requirieron apartarse significativamente de la implementación vista en clase. Los documentos del profesor emplean una estrategia de intercambio de valores seguida de eliminación recursiva del sucesor, aproximación elegante desde una perspectiva algorítmica pero que introduce estados transitorios donde el árbol contiene temporalmente valores duplicados. La solución implementada crea un nuevo nodo con el valor del sucesor y reconfigura todas las referencias en una operación conceptualmente atómica, estrategia que consume notablemente más memoria durante la operación pero elimina completamente los estados inconsistentes intermedios. Esta decisión surgió tras observar comportamientos erráticos durante pruebas concurrentes informales donde múltiples hilos intentaban leer el árbol mientras se ejecutaba una eliminación, escenario no contemplado en los requisitos pero que reveló la fragilidad de mantener estados transitorios inconsistentes.

Los métodos de recorrido implementan la misma lógica recursiva fundamental presente en los materiales académicos pero divergen en el manejo de resultados. Mientras los ejemplos de clase utilizan ArrayList como estructura de acumulación por defecto, el análisis del patrón de uso específico reveló que LinkedList ofrece ventajas medibles para este caso particular. Los recorridos solo realizan inserciones secuenciales al final de la lista, operación donde LinkedList garantiza complejidad temporal constante sin posibilidad de redimensionamiento, mientras ArrayList podría requerir hasta log n operaciones de copia completa del array subyacente durante el recorrido de un árbol balanceado. Aunque la diferencia práctica resulta imperceptible para árboles de menos de 1000 nodos, la elección demuestra consideración por la eficiencia algorítmica incluso en escalas donde el impacto permanece teórico.

La visualización jerárquica del árbol mediante el método imprimir() constituye una adición original no presente en los documentos proporcionados en clase, que se limitan a mostrar los elementos en diversos órdenes sin representación estructural. El algoritmo desarrollado utiliza caracteres ASCII para dibujar las conexiones entre nodos, técnica inspirada en herramientas de línea de comandos de sistemas Unix pero adaptada al contexto Java con la guía de una herramienta de IA como también se ha demostrado ser útil en clase. La implementación requirió experimentación considerable con el manejo de prefijos y la determinación de cuándo un nodo es el último hijo de su padre, lógica que aunque conceptualmente simple, presentó múltiples casos extremos durante las pruebas. El resultado final proporciona retroalimentación visual inmediata sobre la estructura del árbol, característica que demostró ser invaluable durante la depuración.

## Estrategia de Validación y Pruebas

El desarrollo de ArbolTest como clase integral de validación responde a deficiencias identificadas en los ejemplos básicos proporcionados durante el curso, que típicamente demuestran uso correcto sin explorar casos límite o condiciones de error. La batería de pruebas automáticas verifica sistemáticamente comportamientos que los materiales académicos asumen implícitamente pero raramente validan explícitamente, como la respuesta del sistema ante eliminación de la raíz cuando es el único nodo, inserción de elementos duplicados en posiciones críticas del árbol, o búsqueda en subárboles vacíos tras eliminaciones múltiples. Cada prueba surgió de errores reales encontrados durante el desarrollo, creando efectivamente documentación ejecutable de problemas resueltos que futuros mantenedores del código pueden consultar para entender las decisiones de diseño tomadas.

El menú interactivo implementado tras las pruebas automáticas ofrece exploración dinámica ausente en los materiales de referencia del curso. La capacidad de insertar países específicos y observar inmediatamente cómo se posicionan en la estructura jerárquica transformó la comprensión abstracta del árbol binario en manipulación concreta observable. La retroalimentación visual inmediata acelera el proceso de aprendizaje al conectar causa y efecto de manera directa, ventaja pedagógica que justifica las 50 líneas adicionales de código del menú respecto a una implementación puramente funcional.

## Consideraciones Técnicas y Compromisos de Diseño

La ausencia deliberada de mecanismos de autobalanceo refleja una evaluación pragmática del contexto de aplicación más que limitación técnica. Los documentos vistos en clase tampoco incluyen rotaciones o rebalanceo, sugirieno que la complejidad adicional excede los objetivos pedagógicos del curso. Para el universo específico de 195 países reconocidos internacionalmente, incluso un árbol completamente degenerado ejecutaría cualquier operación de manera casi instantanea, haciendo el autobalanceo una optimización prematura que oscurecería los algoritmos fundamentales sin beneficio práctico medible. La decisión de mantener referencias bidireccionales consume aproximadamente 1.6 KB adicionales para el conjunto completo de países, costo que en sistemas con gigabytes de RAM disponible resulta absolutamente trivial comparado con la simplificación algorítmica lograda.

El código resultante prioriza claridad y mantenibilidad sobre micro-optimizaciones de rendimiento, filosofía que contrasta con ciertos ejemplos académicos que persiguen eficiencia teórica a costa de complejidad práctica. La experiencia durante el desarrollo demostró que los errores más costosos en tiempo surgieron de optimizaciones prematuras que complicaron la lógica sin beneficio medible, como un intento inicial de eliminar la recursión en los recorridos mediante pilas explícitas que introdujo tres errores sutiles y solo mejoró el rendimiento de manera inperceptible. La versión final abraza la simplicidad recursiva natural del árbol, reconociendo que para estructuras de menos de 10,000 elementos, la elegancia del código supera marginales ganancias de eficiencia que además resultan eclipsadas por la latencia de entrada/salida en cualquier aplicación práctica.